{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to securities_exchange","text":"<p>A toy example of a Security Exchange in Python</p> <ul> <li>Free software: MIT License</li> </ul>"},{"location":"bookside/","title":"bookside module","text":""},{"location":"bookside/#securities_exchange.bookside.BookSide","title":"<code> BookSide        </code>","text":"<p>Class representing a side (Buy or Sell) of the order book.</p> <p>Attributes:</p> Name Type Description <code>side</code> <code>MarketSide</code> <p>The side of the market (Buy or Sell).</p> <code>_allow_market_queue</code> <code>bool</code> <p>Flag indicating whether market orders are allowed to be queued.</p> <code>_sign</code> <code>int</code> <p>Sign used for heap comparisons based on market side.</p> <code>market_orders</code> <code>deque</code> <p>Queue to store market orders.</p> <code>limit_orders</code> <code>defaultdict</code> <p>Dictionary to store limit orders as dequeues.</p> <code>_bestHeap</code> <code>list</code> <p>Heap structure to efficiently find the best price.</p> <code>bestP</code> <code>float</code> <p>Best price on the order book.</p> <code>bestV</code> <code>int</code> <p>Best volume at the best price.</p> <code>volumes</code> <code>Counter</code> <p>Counter to track volumes at different prices.</p> <p>Methods</p> <p>fill: Match and fill two orders. match: Match and fill an order with the best available order. add: Add an order to the order book. liquid: Check if the order book is liquid. has_market: Check if there are market orders in the queue.</p> Source code in <code>securities_exchange/bookside.py</code> <pre><code>class BookSide:\n\n    \"\"\"\n    Class representing a side (Buy or Sell) of the order book.\n\n    Attributes:\n        side (MarketSide): The side of the market (Buy or Sell).\n        _allow_market_queue (bool): Flag indicating whether market orders are allowed to be queued.\n        _sign (int): Sign used for heap comparisons based on market side.\n        market_orders (deque): Queue to store market orders.\n        limit_orders (defaultdict): Dictionary to store limit orders as dequeues.\n        _bestHeap (list): Heap structure to efficiently find the best price.\n        bestP (float): Best price on the order book.\n        bestV (int): Best volume at the best price.\n        volumes (Counter): Counter to track volumes at different prices.\n\n    Methods:\n        fill: Match and fill two orders.\n        match: Match and fill an order with the best available order.\n        add: Add an order to the order book.\n        liquid: Check if the order book is liquid.\n        has_market: Check if there are market orders in the queue.\n    \"\"\"\n\n    def __init__(self, side: MarketSide = MarketSide.BUY, allow_market_queue: bool = False):\n\n        \"\"\"\n        Initialize a BookSide instance with the given parameters.\n\n        Args:\n            side (MarketSide): The side of the market (Buy or Sell).\n            allow_market_queue (bool): Flag indicating whether market orders are allowed to be queued.\n        \"\"\"\n\n        self.side = side\n        self._allow_market_queue = allow_market_queue\n        self._sign = -1 if self.side == MarketSide.BUY else 1\n        self.market_orders = deque()\n        self.limit_orders = defaultdict(deque)\n        self._bestHeap = []\n        heapify(self._bestHeap)\n        self.bestP = None\n        self.bestV = 0  \n        self.volumes = Counter()\n\n\n    def fill(self, orderA: Order, orderB: Order):\n\n        \"\"\"\n        FIll two orders with each other.\n\n        Args:\n            orderA (Order): First order to match.\n            orderB (Order): Second order to match.\n        \"\"\"\n\n        if orderA.type == OrderType.MARKET:\n            at_price = orderB.price\n        elif orderB.type == OrderType.MARKET:\n            at_price = orderA.price\n        else:\n            # Determine price based on market side and order sides\n            if self.side == MarketSide.BUY:\n                if orderA.side == MarketSide.BUY:\n                    at_price = orderA.price\n                else:\n                    at_price = orderB.price\n            else:\n                if orderA.side == MarketSide.SELL:\n                    at_price = orderA.price\n                else:\n                    at_price = orderB.price\n\n        resA = orderA.residual_size\n        resB = orderB.residual_size\n        orderA.update(resB, at_price, orderB.id)\n        orderB.update(resA, at_price, orderA.id)\n\n\n    def match(self, order: Order, orders: OrderedDict[str, Order]):\n\n        \"\"\"\n        Match an order with the best available order and update book.\n\n        Args:\n            order (Order): The order to match.\n            orders (OrderedDict): Dictionary containing all existing orders.\n        \"\"\"\n\n        if (order.type == OrderType.LIMIT and self.has_market()) and self._allow_market_queue:\n\n            # If order is LIMIT and there are market orders in the queue, match with the first market order in the queue\n            queued_mo = orders[self.market_orders[0]]\n            self.fill(order, queued_mo)\n            if queued_mo.status == OrderStatus.FILLED:\n                self.market_orders.popleft()\n\n        else:\n\n            # Match with the best limit order\n            queued_lo = orders[self.limit_orders[self.bestP][0]]\n            self.fill(order, queued_lo)\n\n            self.volumes[self.bestP] -= queued_lo.matches[-1][0]\n            self.bestV -= queued_lo.matches[-1][0]\n            if queued_lo.status == OrderStatus.FILLED:\n                # If the matched limit order is fully filled remove it from the queue and update order book\n                self.limit_orders[self.bestP].popleft()\n                if len(self.limit_orders[self.bestP]) == 0:\n                    del self.limit_orders[self.bestP]\n                    del self.volumes[self.bestP]\n                    if len(self._bestHeap):\n                        self.bestP = self._sign * heappop(self._bestHeap)\n                        self.bestV = self.volumes[self.bestP]\n                    else:\n                        self.bestP = None\n                        self.bestV = 0                \n\n\n    def add(self, order: Order):\n\n        \"\"\"\n        Add an order to the side of the order book.\n\n        Args:\n            order (Order): The order to be added.\n        \"\"\"\n\n        if (order.type == OrderType.MARKET) and self._allow_market_queue:\n            # If the order is MARKET and market queue is allowed, add to market queue\n            self.market_orders.append(order.id)\n\n        elif order.type == OrderType.LIMIT:\n            # If the order is LIMIT, add to limit orders and update order book\n            if self.bestP is None:\n                self.bestP = order.price\n                self.bestV = order.residual_size                \n            elif (self.bestP &lt; order.price and self.side == MarketSide.BUY) or \\\n                 (self.bestP &gt; order.price and self.side == MarketSide.SELL):\n                heappush(self._bestHeap, self._sign * self.bestP)\n                self.bestP = order.price\n                self.bestV = order.residual_size\n            elif self.bestP == order.price:\n                self.bestV += order.residual_size\n            elif order.price not in self.limit_orders:\n                heappush(self._bestHeap, self._sign * order.price)\n\n            self.limit_orders[order.price].append(order.id)\n            self.volumes[order.price] += order.residual_size\n\n\n    def liquid(self) -&gt; bool:\n        \"\"\"\n        Check if the side of the order book has liquidity.\n\n        Returns:\n            bool: True if the side of the order book has liquidity, False otherwise.\n        \"\"\"\n        return self.bestV &gt; 0\n\n\n    def is_be(self, price) -&gt; bool:\n        \"\"\"\n        Compare price with the current bestP, Better or Equal.\n\n        Args:\n            price (float): price to compare to bestP\n\n        Returns:\n            bool: True if the price is better or equal to bestP, False otherwise.\n        \"\"\"\n        if self.side == MarketSide.BUY:\n            return self.bestP &gt;= price \n        else:\n            return self.bestP &lt;= price \n\n\n    def has_market(self) -&gt; bool:\n        \"\"\"\n        Check if there are market orders in the queue.\n\n        Returns:\n            bool: True if there are market orders, False otherwise.\n        \"\"\"\n        return len(self.market_orders) and self._allow_market_queue\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.__init__","title":"<code>__init__(self, side=&lt;MarketSide.BUY: 1&gt;, allow_market_queue=False)</code>  <code>special</code>","text":"<p>Initialize a BookSide instance with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>MarketSide</code> <p>The side of the market (Buy or Sell).</p> <code>&lt;MarketSide.BUY: 1&gt;</code> <code>allow_market_queue</code> <code>bool</code> <p>Flag indicating whether market orders are allowed to be queued.</p> <code>False</code> Source code in <code>securities_exchange/bookside.py</code> <pre><code>def __init__(self, side: MarketSide = MarketSide.BUY, allow_market_queue: bool = False):\n\n    \"\"\"\n    Initialize a BookSide instance with the given parameters.\n\n    Args:\n        side (MarketSide): The side of the market (Buy or Sell).\n        allow_market_queue (bool): Flag indicating whether market orders are allowed to be queued.\n    \"\"\"\n\n    self.side = side\n    self._allow_market_queue = allow_market_queue\n    self._sign = -1 if self.side == MarketSide.BUY else 1\n    self.market_orders = deque()\n    self.limit_orders = defaultdict(deque)\n    self._bestHeap = []\n    heapify(self._bestHeap)\n    self.bestP = None\n    self.bestV = 0  \n    self.volumes = Counter()\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.add","title":"<code>add(self, order)</code>","text":"<p>Add an order to the side of the order book.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>The order to be added.</p> required Source code in <code>securities_exchange/bookside.py</code> <pre><code>def add(self, order: Order):\n\n    \"\"\"\n    Add an order to the side of the order book.\n\n    Args:\n        order (Order): The order to be added.\n    \"\"\"\n\n    if (order.type == OrderType.MARKET) and self._allow_market_queue:\n        # If the order is MARKET and market queue is allowed, add to market queue\n        self.market_orders.append(order.id)\n\n    elif order.type == OrderType.LIMIT:\n        # If the order is LIMIT, add to limit orders and update order book\n        if self.bestP is None:\n            self.bestP = order.price\n            self.bestV = order.residual_size                \n        elif (self.bestP &lt; order.price and self.side == MarketSide.BUY) or \\\n             (self.bestP &gt; order.price and self.side == MarketSide.SELL):\n            heappush(self._bestHeap, self._sign * self.bestP)\n            self.bestP = order.price\n            self.bestV = order.residual_size\n        elif self.bestP == order.price:\n            self.bestV += order.residual_size\n        elif order.price not in self.limit_orders:\n            heappush(self._bestHeap, self._sign * order.price)\n\n        self.limit_orders[order.price].append(order.id)\n        self.volumes[order.price] += order.residual_size\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.fill","title":"<code>fill(self, orderA, orderB)</code>","text":"<p>FIll two orders with each other.</p> <p>Parameters:</p> Name Type Description Default <code>orderA</code> <code>Order</code> <p>First order to match.</p> required <code>orderB</code> <code>Order</code> <p>Second order to match.</p> required Source code in <code>securities_exchange/bookside.py</code> <pre><code>def fill(self, orderA: Order, orderB: Order):\n\n    \"\"\"\n    FIll two orders with each other.\n\n    Args:\n        orderA (Order): First order to match.\n        orderB (Order): Second order to match.\n    \"\"\"\n\n    if orderA.type == OrderType.MARKET:\n        at_price = orderB.price\n    elif orderB.type == OrderType.MARKET:\n        at_price = orderA.price\n    else:\n        # Determine price based on market side and order sides\n        if self.side == MarketSide.BUY:\n            if orderA.side == MarketSide.BUY:\n                at_price = orderA.price\n            else:\n                at_price = orderB.price\n        else:\n            if orderA.side == MarketSide.SELL:\n                at_price = orderA.price\n            else:\n                at_price = orderB.price\n\n    resA = orderA.residual_size\n    resB = orderB.residual_size\n    orderA.update(resB, at_price, orderB.id)\n    orderB.update(resA, at_price, orderA.id)\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.has_market","title":"<code>has_market(self)</code>","text":"<p>Check if there are market orders in the queue.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there are market orders, False otherwise.</p> Source code in <code>securities_exchange/bookside.py</code> <pre><code>def has_market(self) -&gt; bool:\n    \"\"\"\n    Check if there are market orders in the queue.\n\n    Returns:\n        bool: True if there are market orders, False otherwise.\n    \"\"\"\n    return len(self.market_orders) and self._allow_market_queue\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.is_be","title":"<code>is_be(self, price)</code>","text":"<p>Compare price with the current bestP, Better or Equal.</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <code>float</code> <p>price to compare to bestP</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the price is better or equal to bestP, False otherwise.</p> Source code in <code>securities_exchange/bookside.py</code> <pre><code>def is_be(self, price) -&gt; bool:\n    \"\"\"\n    Compare price with the current bestP, Better or Equal.\n\n    Args:\n        price (float): price to compare to bestP\n\n    Returns:\n        bool: True if the price is better or equal to bestP, False otherwise.\n    \"\"\"\n    if self.side == MarketSide.BUY:\n        return self.bestP &gt;= price \n    else:\n        return self.bestP &lt;= price \n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.liquid","title":"<code>liquid(self)</code>","text":"<p>Check if the side of the order book has liquidity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the side of the order book has liquidity, False otherwise.</p> Source code in <code>securities_exchange/bookside.py</code> <pre><code>def liquid(self) -&gt; bool:\n    \"\"\"\n    Check if the side of the order book has liquidity.\n\n    Returns:\n        bool: True if the side of the order book has liquidity, False otherwise.\n    \"\"\"\n    return self.bestV &gt; 0\n</code></pre>"},{"location":"bookside/#securities_exchange.bookside.BookSide.match","title":"<code>match(self, order, orders)</code>","text":"<p>Match an order with the best available order and update book.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>The order to match.</p> required <code>orders</code> <code>OrderedDict</code> <p>Dictionary containing all existing orders.</p> required Source code in <code>securities_exchange/bookside.py</code> <pre><code>def match(self, order: Order, orders: OrderedDict[str, Order]):\n\n    \"\"\"\n    Match an order with the best available order and update book.\n\n    Args:\n        order (Order): The order to match.\n        orders (OrderedDict): Dictionary containing all existing orders.\n    \"\"\"\n\n    if (order.type == OrderType.LIMIT and self.has_market()) and self._allow_market_queue:\n\n        # If order is LIMIT and there are market orders in the queue, match with the first market order in the queue\n        queued_mo = orders[self.market_orders[0]]\n        self.fill(order, queued_mo)\n        if queued_mo.status == OrderStatus.FILLED:\n            self.market_orders.popleft()\n\n    else:\n\n        # Match with the best limit order\n        queued_lo = orders[self.limit_orders[self.bestP][0]]\n        self.fill(order, queued_lo)\n\n        self.volumes[self.bestP] -= queued_lo.matches[-1][0]\n        self.bestV -= queued_lo.matches[-1][0]\n        if queued_lo.status == OrderStatus.FILLED:\n            # If the matched limit order is fully filled remove it from the queue and update order book\n            self.limit_orders[self.bestP].popleft()\n            if len(self.limit_orders[self.bestP]) == 0:\n                del self.limit_orders[self.bestP]\n                del self.volumes[self.bestP]\n                if len(self._bestHeap):\n                    self.bestP = self._sign * heappop(self._bestHeap)\n                    self.bestV = self.volumes[self.bestP]\n                else:\n                    self.bestP = None\n                    self.bestV = 0                \n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/ggnne/securities-exchange/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>securities-exchange could always use more documentation, whether as part of the official securities-exchange docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/ggnne/securities-exchange/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up securities-exchange for local development.</p> <ol> <li> <p>Fork the securities-exchange repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/securities-exchange.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv securities-exchange\n$ cd securities-exchange/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 securities-exchange tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/ggnne/securities-exchange/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install securities-exchange, run this command in your terminal:</p> <pre><code>pip install securities-exchange\n</code></pre> <p>This is the preferred method to install securities-exchange, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install securities-exchange from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/ggnne/securities-exchange\n</code></pre>"},{"location":"order/","title":"order module","text":""},{"location":"order/#securities_exchange.order.Order","title":"<code> Order        </code>","text":"<p>Class representing an order in the securities exchange.</p> <p>Attributes:</p> Name Type Description <code>ticker</code> <code>str</code> <p>Ticker symbol for the order.</p> <code>type</code> <code>OrderType</code> <p>Type of the order (Market or Limit).</p> <code>side</code> <code>MarketSide</code> <p>Side of the market (Buy or Sell).</p> <code>size</code> <code>int</code> <p>Size of the order.</p> <code>price</code> <code>float</code> <p>Price of the order (optional for Market orders).</p> <code>timestamp</code> <code>int</code> <p>Timestamp of order creation.</p> <code>status</code> <code>OrderStatus</code> <p>Status of the order (UNFILLED, PARTIALLY_FILLED, FILLED).</p> <code>matches</code> <code>deque</code> <p>Queue to store order matches.</p> <code>residual_size</code> <code>int</code> <p>Remaining size to be filled.</p> <code>avg_fill_price</code> <code>float</code> <p>Average fill price of the order.</p> <code>error</code> <code>bool</code> <p>Flag indicating if there's an error in the order.</p> <p>Methods</p> <p>update: Updates the order status and properties after a fill.</p> Source code in <code>securities_exchange/order.py</code> <pre><code>class Order:\n\n    \"\"\"\n    Class representing an order in the securities exchange.\n\n    Attributes:\n        ticker (str): Ticker symbol for the order.\n        type (OrderType): Type of the order (Market or Limit).\n        side (MarketSide): Side of the market (Buy or Sell).\n        size (int): Size of the order.\n        price (float): Price of the order (optional for Market orders).\n        timestamp (int): Timestamp of order creation.\n        status (OrderStatus): Status of the order (UNFILLED, PARTIALLY_FILLED, FILLED).\n        matches (deque): Queue to store order matches.\n        residual_size (int): Remaining size to be filled.\n        avg_fill_price (float): Average fill price of the order.\n        error (bool): Flag indicating if there's an error in the order.\n\n    Methods:\n        update: Updates the order status and properties after a fill.\n    \"\"\"    \n\n    @validate_call\n    def __init__(self, ticker: str, type: OrderType, side: MarketSide, size: int, price: float = None):\n\n        \"\"\"\n        Initialize an order with the provided parameters.\n\n        Args:\n            ticker (str): Ticker symbol for the order.\n            type (OrderType): Type of the order (Market or Limit).\n            side (MarketSide): Side of the market (Buy or Sell).\n            size (int): Size of the order.\n            price (float): Price of the order (optional for Market orders).\n        \"\"\"\n\n        # Set timestamp to current time in microseconds\n        self.timestamp = int(datetime.now().timestamp() * 1e6)\n        self.ticker = ticker\n        self.type = type\n        self.side = side\n        self.size = size\n        self.price = price\n        self.status = OrderStatus.UNFILLED\n        self.matches = deque()\n        self.residual_size = size\n        self.avg_fill_price = 0\n        self.error = False\n\n        # Handle special cases for market orders\n        if self.price is not None and self.type == OrderType.MARKET:\n            logger.warning(\"Market orders will ignore 'price'. Price attribute set to None\")\n            self.price = None        \n\n        # Generate a unique order ID based on order attributes\n        keys = [self.timestamp, self.ticker, self.type.name, self.side.name, self.size]\n        if self.price is not None and self.type == OrderType.LIMIT:\n            keys.append(f\"@{self.price}\")\n        self.id = ''.join(map(str, keys))\n\n\n    def __repr__(self) -&gt; str:\n        d = {k: v for k, v in self.__dict__.items()}\n        d[\"type\"] = d[\"type\"].name\n        d[\"side\"] = d[\"side\"].name\n        d[\"status\"] = d[\"status\"].name\n        d[\"matches\"] = len(d[\"matches\"])\n        if d[\"price\"] is None:\n            del d[\"price\"] \n        _repr = \",\\n      \".join(map(lambda x: f\"{x[0]} = {x[1]}\", d.items()))\n        return f\"Order({_repr})\"\n\n\n    def update(self, filled_quantity: int, at_price: float, matched_order_id: str):\n\n        \"\"\"\n        Update the order after a fill.\n\n        Args:\n            filled_quantity (int): Quantity filled in the latest match.\n            at_price (float): Price at which the latest match occurred.\n            matched_order_id (str): ID of the order that was matched.\n        \"\"\"\n\n        # Ensure filled_quantity does not exceed the remaining size\n        filled_quantity = min(filled_quantity, self.residual_size)\n\n        # Update average fill price\n        self.avg_fill_price *= (self.size - self.residual_size)\n        self.avg_fill_price += filled_quantity * at_price\n        self.avg_fill_price /= (self.size - self.residual_size + filled_quantity)\n\n        # Update residual size\n        self.residual_size -= filled_quantity\n\n        # Update order status based on residual size\n        if self.residual_size == 0:\n            self.status = OrderStatus.FILLED\n            logger.info(f\"Order {self.id} filled {filled_quantity} units at price {at_price} with order {matched_order_id}\")\n        elif self.residual_size &gt; 0:\n            self.status = OrderStatus.PARTIALLY_FILLED\n            logger.info(f\"Order {self.id} partially filled {filled_quantity} units at price {at_price} with order {matched_order_id}\")\n\n        # Record the match in the matches queue\n        self.matches.append((filled_quantity, at_price, matched_order_id))\n</code></pre>"},{"location":"order/#securities_exchange.order.Order.__init__","title":"<code>__init__(self, ticker, type, side, size, price=None)</code>  <code>special</code>","text":"<p>Initialize an order with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Ticker symbol for the order.</p> required <code>type</code> <code>OrderType</code> <p>Type of the order (Market or Limit).</p> required <code>side</code> <code>MarketSide</code> <p>Side of the market (Buy or Sell).</p> required <code>size</code> <code>int</code> <p>Size of the order.</p> required <code>price</code> <code>float</code> <p>Price of the order (optional for Market orders).</p> <code>None</code> Source code in <code>securities_exchange/order.py</code> <pre><code>@validate_call\ndef __init__(self, ticker: str, type: OrderType, side: MarketSide, size: int, price: float = None):\n\n    \"\"\"\n    Initialize an order with the provided parameters.\n\n    Args:\n        ticker (str): Ticker symbol for the order.\n        type (OrderType): Type of the order (Market or Limit).\n        side (MarketSide): Side of the market (Buy or Sell).\n        size (int): Size of the order.\n        price (float): Price of the order (optional for Market orders).\n    \"\"\"\n\n    # Set timestamp to current time in microseconds\n    self.timestamp = int(datetime.now().timestamp() * 1e6)\n    self.ticker = ticker\n    self.type = type\n    self.side = side\n    self.size = size\n    self.price = price\n    self.status = OrderStatus.UNFILLED\n    self.matches = deque()\n    self.residual_size = size\n    self.avg_fill_price = 0\n    self.error = False\n\n    # Handle special cases for market orders\n    if self.price is not None and self.type == OrderType.MARKET:\n        logger.warning(\"Market orders will ignore 'price'. Price attribute set to None\")\n        self.price = None        \n\n    # Generate a unique order ID based on order attributes\n    keys = [self.timestamp, self.ticker, self.type.name, self.side.name, self.size]\n    if self.price is not None and self.type == OrderType.LIMIT:\n        keys.append(f\"@{self.price}\")\n    self.id = ''.join(map(str, keys))\n</code></pre>"},{"location":"order/#securities_exchange.order.Order.update","title":"<code>update(self, filled_quantity, at_price, matched_order_id)</code>","text":"<p>Update the order after a fill.</p> <p>Parameters:</p> Name Type Description Default <code>filled_quantity</code> <code>int</code> <p>Quantity filled in the latest match.</p> required <code>at_price</code> <code>float</code> <p>Price at which the latest match occurred.</p> required <code>matched_order_id</code> <code>str</code> <p>ID of the order that was matched.</p> required Source code in <code>securities_exchange/order.py</code> <pre><code>def update(self, filled_quantity: int, at_price: float, matched_order_id: str):\n\n    \"\"\"\n    Update the order after a fill.\n\n    Args:\n        filled_quantity (int): Quantity filled in the latest match.\n        at_price (float): Price at which the latest match occurred.\n        matched_order_id (str): ID of the order that was matched.\n    \"\"\"\n\n    # Ensure filled_quantity does not exceed the remaining size\n    filled_quantity = min(filled_quantity, self.residual_size)\n\n    # Update average fill price\n    self.avg_fill_price *= (self.size - self.residual_size)\n    self.avg_fill_price += filled_quantity * at_price\n    self.avg_fill_price /= (self.size - self.residual_size + filled_quantity)\n\n    # Update residual size\n    self.residual_size -= filled_quantity\n\n    # Update order status based on residual size\n    if self.residual_size == 0:\n        self.status = OrderStatus.FILLED\n        logger.info(f\"Order {self.id} filled {filled_quantity} units at price {at_price} with order {matched_order_id}\")\n    elif self.residual_size &gt; 0:\n        self.status = OrderStatus.PARTIALLY_FILLED\n        logger.info(f\"Order {self.id} partially filled {filled_quantity} units at price {at_price} with order {matched_order_id}\")\n\n    # Record the match in the matches queue\n    self.matches.append((filled_quantity, at_price, matched_order_id))\n</code></pre>"},{"location":"orderbook/","title":"orderbook module","text":""},{"location":"orderbook/#securities_exchange.orderbook.OrderBook","title":"<code> OrderBook        </code>","text":"<p>Class representing an order book in a securities exchange.</p> <p>Attributes:</p> Name Type Description <code>Bid</code> <code>BookSide</code> <p>The buy side of the order book.</p> <code>Ask</code> <code>BookSide</code> <p>The sell side of the order book.</p> <p>Methods</p> <p>process_order: Processes an incoming order, matching and filling as needed.</p> Source code in <code>securities_exchange/orderbook.py</code> <pre><code>class OrderBook:\n\n    \"\"\"\n    Class representing an order book in a securities exchange.\n\n    Attributes:\n        Bid (BookSide): The buy side of the order book.\n        Ask (BookSide): The sell side of the order book.\n\n    Methods:\n        process_order: Processes an incoming order, matching and filling as needed.\n\n    \"\"\"\n\n    def __init__(self, allow_market_queue: bool = False):\n        \"\"\"\n        Initialize an OrderBook instance.\n\n        Args:\n            allow_market_queue (bool): Flag indicating whether market orders can be queued.\n        \"\"\"\n        # Create instances of BookSide for buy (Bid) and sell (Ask) sides\n        self.Bid = BookSide(allow_market_queue = allow_market_queue)\n        self.Ask = BookSide(side = MarketSide.SELL, allow_market_queue = allow_market_queue)\n\n    def process_order(self, order: Order, orders: OrderedDict[str, Order]):\n\n        \"\"\"\n        Process an incoming order, matching and filling as needed.\n\n        Args:\n            order (Order): The incoming order to be processed.\n            orders (OrderedDict): Dictionary containing all existing orders.\n        \"\"\"\n\n        # Determine the sides for matching and adding based on the order's side\n        if (order.side == MarketSide.BUY):\n            side_for_match = self.Ask\n            side_to_add = self.Bid\n        else:\n            side_for_match = self.Bid\n            side_to_add = self.Ask\n\n        if order.type == OrderType.MARKET:\n\n            # Continue processing the order until it is fully filled or cannot be matched\n            while (order.status != OrderStatus.FILLED and side_for_match.liquid()):\n                side_for_match.match(order, orders)\n\n        else:\n\n            # Continue processing the order until it is fully filled or cannot be matched\n            while (order.status != OrderStatus.FILLED and \\\n                   ((side_for_match.liquid() and side_for_match.is_be(order.price)) or (side_for_match.has_market()))):\n                side_for_match.match(order, orders)\n\n       # If the order is still not fully filled, add it to the appropriate side of the order book\n        if (order.status != OrderStatus.FILLED):\n            side_to_add.add(order)\n</code></pre>"},{"location":"orderbook/#securities_exchange.orderbook.OrderBook.__init__","title":"<code>__init__(self, allow_market_queue=False)</code>  <code>special</code>","text":"<p>Initialize an OrderBook instance.</p> <p>Parameters:</p> Name Type Description Default <code>allow_market_queue</code> <code>bool</code> <p>Flag indicating whether market orders can be queued.</p> <code>False</code> Source code in <code>securities_exchange/orderbook.py</code> <pre><code>def __init__(self, allow_market_queue: bool = False):\n    \"\"\"\n    Initialize an OrderBook instance.\n\n    Args:\n        allow_market_queue (bool): Flag indicating whether market orders can be queued.\n    \"\"\"\n    # Create instances of BookSide for buy (Bid) and sell (Ask) sides\n    self.Bid = BookSide(allow_market_queue = allow_market_queue)\n    self.Ask = BookSide(side = MarketSide.SELL, allow_market_queue = allow_market_queue)\n</code></pre>"},{"location":"orderbook/#securities_exchange.orderbook.OrderBook.process_order","title":"<code>process_order(self, order, orders)</code>","text":"<p>Process an incoming order, matching and filling as needed.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>The incoming order to be processed.</p> required <code>orders</code> <code>OrderedDict</code> <p>Dictionary containing all existing orders.</p> required Source code in <code>securities_exchange/orderbook.py</code> <pre><code>def process_order(self, order: Order, orders: OrderedDict[str, Order]):\n\n    \"\"\"\n    Process an incoming order, matching and filling as needed.\n\n    Args:\n        order (Order): The incoming order to be processed.\n        orders (OrderedDict): Dictionary containing all existing orders.\n    \"\"\"\n\n    # Determine the sides for matching and adding based on the order's side\n    if (order.side == MarketSide.BUY):\n        side_for_match = self.Ask\n        side_to_add = self.Bid\n    else:\n        side_for_match = self.Bid\n        side_to_add = self.Ask\n\n    if order.type == OrderType.MARKET:\n\n        # Continue processing the order until it is fully filled or cannot be matched\n        while (order.status != OrderStatus.FILLED and side_for_match.liquid()):\n            side_for_match.match(order, orders)\n\n    else:\n\n        # Continue processing the order until it is fully filled or cannot be matched\n        while (order.status != OrderStatus.FILLED and \\\n               ((side_for_match.liquid() and side_for_match.is_be(order.price)) or (side_for_match.has_market()))):\n            side_for_match.match(order, orders)\n\n   # If the order is still not fully filled, add it to the appropriate side of the order book\n    if (order.status != OrderStatus.FILLED):\n        side_to_add.add(order)\n</code></pre>"},{"location":"securities_exchange/","title":"securities_exchange module","text":""},{"location":"securities_exchange/#securities_exchange.securities_exchange.SecuritiesExchange","title":"<code> SecuritiesExchange        </code>","text":"<p>Class representing a securities exchange.</p> <p>Attributes:</p> Name Type Description <code>orders</code> <code>OrderedDict</code> <p>Dictionary to store all submitted orders.</p> <code>rejected_orders</code> <code>OrderedDict</code> <p>Dictionary to store rejected orders.</p> <code>markets</code> <code>dict</code> <p>Dictionary to store order books for different tickers.</p> <code>_allow_market_queue</code> <code>bool</code> <p>Flag indicating whether market orders can be queued.</p> <p>Methods</p> <p>_init_market: Initializes an order book for a new ticker. _validate_order: Validates the properties of an order and logs errors if any. submit_order: Submits an order to the exchange for processing. get_order: Retrieves an order based on its ID.</p> Source code in <code>securities_exchange/securities_exchange.py</code> <pre><code>class SecuritiesExchange:\n\n    \"\"\"\n    Class representing a securities exchange.\n\n    Attributes:\n        orders (OrderedDict): Dictionary to store all submitted orders.\n        rejected_orders (OrderedDict): Dictionary to store rejected orders.\n        markets (dict): Dictionary to store order books for different tickers.\n        _allow_market_queue (bool): Flag indicating whether market orders can be queued.\n\n    Methods:\n        _init_market: Initializes an order book for a new ticker.\n        _validate_order: Validates the properties of an order and logs errors if any.\n        submit_order: Submits an order to the exchange for processing.\n        get_order: Retrieves an order based on its ID.\n    \"\"\"\n\n    def __init__(self, allow_market_queue: bool = False):\n\n        \"\"\"\n        Initialize a SecuritiesExchange instance.\n\n        Args:\n            allow_market_queue (bool): Flag indicating whether market orders can be queued.\n        \"\"\"\n\n        self.orders = OrderedDict()\n        self.rejected_orders = OrderedDict()\n        self.markets = {}\n        self._allow_market_queue = allow_market_queue\n\n\n    def _init_market(self, ticker: str):\n\n        \"\"\"\n        Initialize an order book for a new ticker.\n\n        Args:\n            ticker (str): Ticker symbol for the market.\n        \"\"\"\n\n        self.markets[ticker] = OrderBook(allow_market_queue=self._allow_market_queue)\n\n\n    def _validate_order(self, order: Order):\n\n        \"\"\"\n        Validate the properties of an order and log errors if any.\n\n        Args:\n            order (Order): The order to be validated.\n        \"\"\"\n\n        msg = f\"Order {order.id} has been REJECTED.\"\n        if (order.price is None or order.price &lt;= 0) and (order.type == OrderType.LIMIT):\n            order.error = True\n            msg += \"\\n\\t- LIMIT orders require a non-null positive PRICE.\"\n\n        if (order.size &lt;= 0):\n            order.error = True\n            msg += \"\\n\\t- Orders require a non-null positive SIZE.\"\n\n        if order.error:\n            logger.error(msg)\n\n\n    def submit_order(self, order: Order) -&gt; bool:\n\n        \"\"\"\n        Submits an order to the exchange for processing.\n\n        Args:\n            order (Order): The order to be submitted.\n\n        Returns:\n            bool: True if the order is successfully submitted, False otherwise.\n        \"\"\"\n\n        # Validate the order before processing\n        self._validate_order(order)\n\n        if order.error:\n            # If the order is invalid, store it in the rejected_orders dictionary and return False\n            self.rejected_orders[order.id] = order\n            return False\n\n        if order.ticker not in self.markets:\n            # If the ticker is not in markets, initialize a new market\n            self._init_market(order.ticker)\n\n        # Store the order in the orders dictionary\n        self.orders[order.id] = order\n\n        logger.info(f\"Order {order.id} submitted for {order.ticker}\")\n\n        # Process the order in the corresponding market\n        self.markets[order.ticker].process_order(order, self.orders)\n\n        # Log information about the order based on the market queue settings\n        if self._allow_market_queue:\n            if (order.type == OrderType.MARKET) and (order.status == OrderStatus.UNFILLED):             \n                logger.info(f\"Order {order.id} has been added to the Market Orders queue for the full amount.\")\n            elif (order.type == OrderType.MARKET) and (order.status == OrderStatus.PARTIALLY_FILLED):\n                logger.info(f\"Order {order.id} has been added to the Market Orders queue for the residual amount of {order.residual_size} units.\")\n        else:\n            if (order.type == OrderType.MARKET) and (order.status == OrderStatus.UNFILLED):             \n                logger.info(f\"Order {order.id} couldn't be matched.\")\n\n        return True\n\n\n    def get_order(self, order_id: str) -&gt; Order:\n\n        \"\"\"\n        Retrieves an order based on its ID.\n\n        Args:\n            order_id (str): The ID of the order to retrieve.\n\n        Returns:\n            Order: The order corresponding to the given ID.\n        \"\"\"\n\n        if order_id in self.orders:\n            return self.orders.get(order_id)\n\n        return self.rejected_orders.get(order_id)\n</code></pre>"},{"location":"securities_exchange/#securities_exchange.securities_exchange.SecuritiesExchange.__init__","title":"<code>__init__(self, allow_market_queue=False)</code>  <code>special</code>","text":"<p>Initialize a SecuritiesExchange instance.</p> <p>Parameters:</p> Name Type Description Default <code>allow_market_queue</code> <code>bool</code> <p>Flag indicating whether market orders can be queued.</p> <code>False</code> Source code in <code>securities_exchange/securities_exchange.py</code> <pre><code>def __init__(self, allow_market_queue: bool = False):\n\n    \"\"\"\n    Initialize a SecuritiesExchange instance.\n\n    Args:\n        allow_market_queue (bool): Flag indicating whether market orders can be queued.\n    \"\"\"\n\n    self.orders = OrderedDict()\n    self.rejected_orders = OrderedDict()\n    self.markets = {}\n    self._allow_market_queue = allow_market_queue\n</code></pre>"},{"location":"securities_exchange/#securities_exchange.securities_exchange.SecuritiesExchange.get_order","title":"<code>get_order(self, order_id)</code>","text":"<p>Retrieves an order based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>str</code> <p>The ID of the order to retrieve.</p> required <p>Returns:</p> Type Description <code>Order</code> <p>The order corresponding to the given ID.</p> Source code in <code>securities_exchange/securities_exchange.py</code> <pre><code>def get_order(self, order_id: str) -&gt; Order:\n\n    \"\"\"\n    Retrieves an order based on its ID.\n\n    Args:\n        order_id (str): The ID of the order to retrieve.\n\n    Returns:\n        Order: The order corresponding to the given ID.\n    \"\"\"\n\n    if order_id in self.orders:\n        return self.orders.get(order_id)\n\n    return self.rejected_orders.get(order_id)\n</code></pre>"},{"location":"securities_exchange/#securities_exchange.securities_exchange.SecuritiesExchange.submit_order","title":"<code>submit_order(self, order)</code>","text":"<p>Submits an order to the exchange for processing.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>The order to be submitted.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the order is successfully submitted, False otherwise.</p> Source code in <code>securities_exchange/securities_exchange.py</code> <pre><code>def submit_order(self, order: Order) -&gt; bool:\n\n    \"\"\"\n    Submits an order to the exchange for processing.\n\n    Args:\n        order (Order): The order to be submitted.\n\n    Returns:\n        bool: True if the order is successfully submitted, False otherwise.\n    \"\"\"\n\n    # Validate the order before processing\n    self._validate_order(order)\n\n    if order.error:\n        # If the order is invalid, store it in the rejected_orders dictionary and return False\n        self.rejected_orders[order.id] = order\n        return False\n\n    if order.ticker not in self.markets:\n        # If the ticker is not in markets, initialize a new market\n        self._init_market(order.ticker)\n\n    # Store the order in the orders dictionary\n    self.orders[order.id] = order\n\n    logger.info(f\"Order {order.id} submitted for {order.ticker}\")\n\n    # Process the order in the corresponding market\n    self.markets[order.ticker].process_order(order, self.orders)\n\n    # Log information about the order based on the market queue settings\n    if self._allow_market_queue:\n        if (order.type == OrderType.MARKET) and (order.status == OrderStatus.UNFILLED):             \n            logger.info(f\"Order {order.id} has been added to the Market Orders queue for the full amount.\")\n        elif (order.type == OrderType.MARKET) and (order.status == OrderStatus.PARTIALLY_FILLED):\n            logger.info(f\"Order {order.id} has been added to the Market Orders queue for the residual amount of {order.residual_size} units.\")\n    else:\n        if (order.type == OrderType.MARKET) and (order.status == OrderStatus.UNFILLED):             \n            logger.info(f\"Order {order.id} couldn't be matched.\")\n\n    return True\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#overview","title":"Overview","text":"<p>The securities-exchange package provides a simple framework for simulating a securities exchange. This package allows you to model and test different order types, market behaviors, and exchange rules. Installation</p>"},{"location":"usage/#getting-started","title":"Getting Started","text":"<p>To use the package, you need to import the necessary classes and functions:</p> <pre><code>from securities_exchange import SecuritiesExchange, Order, OrderType, MarketSide\n</code></pre> <p>The primary classes include:</p> <ul> <li>SecuritiesExchange: Represents the securities exchange.</li> <li>Order: Represents an order with specific details like ticker, order type, side, size, and price.</li> <li>OrderType: Enum defining order types (MARKET, LIMIT).</li> <li>MarketSide: Enum defining market sides (BUY, SELL).</li> </ul>"},{"location":"usage/#exchange-modes","title":"Exchange Modes","text":"<p>The <code>SecuritiesExchange</code> class has two modes of operation:</p> <ol> <li>Default Mode:<ul> <li>The exchange takes Market Orders and tries to fill them given the available liquidity.</li> <li>If Market Orders remain UNFILLED or PARTIALLY FILLED due to insufficient liquidity, they exit with the achieved status.</li> </ul> </li> <li>Queue Mode (allow_market_queue=True):<ul> <li>UNFILLED / PARTIALLY UNFILLED Market Orders don't exit from the exchange.</li> <li>They get queued into a \"priority\" queue and will be filled at the next available opportunity, i.e., with the next Limit order that arrives on the opposite side.</li> </ul> </li> </ol>"},{"location":"usage/#usage-example-default-mode","title":"Usage Example - Default Mode","text":"<pre><code>secEx = SecuritiesExchange()\n\norders = [\n    Order(\"MSFT\", OrderType.MARKET, MarketSide.BUY, 10),\n    Order(\"MSFT\", OrderType.LIMIT, MarketSide.SELL, 10, 411.10),\n    # ... other orders\n]\n\nfor order in orders:\n    secEx.submit_order(order)\n</code></pre>"},{"location":"usage/#usage-example-market-queue-mode","title":"Usage Example - Market Queue Mode","text":"<pre><code>secEx_withMarketQueue = SecuritiesExchange(allow_market_queue=True)\n\norders = [\n    Order(\"MSFT\", OrderType.MARKET, MarketSide.BUY, 10),\n    Order(\"MSFT\", OrderType.LIMIT, MarketSide.SELL, 10, 411.10),\n    # ... other orders\n]\n\nfor order in orders:\n    secEx_withMarketQueue.submit_order(order)\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>from securities_exchange import (SecuritiesExchange, \n                                 Order, \n                                 OrderType, \n                                 MarketSide)\n</pre> from securities_exchange import (SecuritiesExchange,                                   Order,                                   OrderType,                                   MarketSide) In\u00a0[2]: Copied! <pre>orders = [Order(\"MSFT\", OrderType.MARKET, MarketSide.BUY, 10),\n          Order(\"MSFT\", OrderType.LIMIT, MarketSide.SELL, 10, 411.10),\n          Order(\"AMZN\", OrderType.LIMIT, MarketSide.BUY, 1000, 160.),\n          Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 30),\n          Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 20),\n          Order(\"GS\", OrderType.LIMIT, MarketSide.BUY, -10, -20),\n          Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 10, 7),\n          Order(\"GS\", OrderType.LIMIT, MarketSide.SELL, 40, 387.20)]\n</pre> orders = [Order(\"MSFT\", OrderType.MARKET, MarketSide.BUY, 10),           Order(\"MSFT\", OrderType.LIMIT, MarketSide.SELL, 10, 411.10),           Order(\"AMZN\", OrderType.LIMIT, MarketSide.BUY, 1000, 160.),           Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 30),           Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 20),           Order(\"GS\", OrderType.LIMIT, MarketSide.BUY, -10, -20),           Order(\"GS\", OrderType.MARKET, MarketSide.BUY, 10, 7),           Order(\"GS\", OrderType.LIMIT, MarketSide.SELL, 40, 387.20)]  <pre>Market orders will ignore 'price'. Price attribute set to None\n</pre> In\u00a0[3]: Copied! <pre>secEx = SecuritiesExchange()\n</pre> secEx = SecuritiesExchange()  In\u00a0[4]: Copied! <pre>for order in orders:\n    secEx.submit_order(order)\n</pre> for order in orders:     secEx.submit_order(order) <pre>Order 1707858511901235GSLIMITBUY-10@-20.0 has been REJECTED.\n\t- LIMIT orders require a non-null positive PRICE.\n\t- Orders require a non-null positive SIZE.\n</pre>"},{"location":"examples/intro/#creating-some-orders","title":"Creating some orders\u00b6","text":""},{"location":"examples/intro/#create-a-the-security-exchange-object","title":"Create a the Security Exchange object\u00b6","text":"<p>SecuritiesExchange has 2 arguments:</p> <ul> <li>allow_market_queue: that allows for unfilled or partially filled Market orders to be queued waiting for a matching Limit order to come, default is False so unfilled or partially unfilled Market orders will remain as such while with True they could be filled eventually and they will have priority on the limit orders.</li> </ul>"},{"location":"examples/intro/#feed-the-orders-to-the-exchange","title":"Feed the orders to the exchange\u00b6","text":""}]}